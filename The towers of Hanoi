import sys, pygame, time
from pygame.locals import *
from tkinter import *
import tkinter.font as font

root = Tk()
timePoint = time.time()
root.geometry('500x180')
root.title('Ring selection:')
root.resizable(False, False)
palette2 = ['Red','Blue','Green', 'Yellow', 'orange', 'purple']

def on_click(text):
    global numberofrings
    numberofrings = text
    root.destroy()

def makeButton(xval,yval, text, colour):
    bgcol = palette2[i]
    button = Button(root, text = ' '+str(text)+' ', font=('impact',20), command = lambda:  on_click(text), bg = bgcol)
    button.place(x= xval, y= yval, anchor='center')

myLabel = Label(root, text='Welcome to the Towers of Hanoi,\nHow many rings do you want to start with?:', font=("impact", 20))
myLabel.pack()
for i in range(6):
    makeButton(120+50*i, 120, i+3, i)    
help = Button(root, text= 'Help', command = lambda: helpme())
help.place(x =455, y=150)

def helpme():
    roothelp = Tk()
    roothelp.geometry('1000x140')
    roothelp.title('Help')
    roothelp.resizable(False, False)
    texthelptext = """\n The towers of Hanoi is a puzzle where you must move all the rings on the first tower to the last.
However: you can only place smaller rings on larger ones, and can only take rings from the top of the tower.
    """
    myLabel = Label(roothelp, text=texthelptext, font=('calibri', 15))
    begin = Button(roothelp, text = ' Begin ', font=('calibri', 15), command = lambda: roothelp.destroy())
    begin.place(x=500,y=80)
    myLabel.pack()

root.mainloop()

#########################################

pygame.init()
surface = pygame.display.set_mode((640, 480))
my_font = pygame.font.SysFont('consolas', 35)
small_font = pygame.font.SysFont('consolas', 25)
clock = pygame.time.Clock()
surfrect = surface.get_rect()

def theywon():
    pygame.quit()
    root = Tk()
    root.geometry('960x540')
    root.title('WOO HOO')

    myLabel = Label(root, text='Congratulations,\n you won!', font=("impact", 50))
    myLabel.place(y = 150, x = 250)
    root.resizable(False, False)
    root.mainloop()

class Ring():
    _before = None
    def __init__(self, size = 1, colour = (0,0,0)):
        rect = pygame.Rect((0, 0), (16*size, 16))
        rect.center = (surfrect.w / 2, surfrect.h / 2)
        self.Rect = rect
        self.Before = rect
        self.colour = colour
        self.size = size
    
    def touched(self, pos):
        return self.Rect.collidepoint(pos)

    def draw(self):
        surface.fill(self.colour, self.Rect)

    def move(self, pos):
        self.Rect.move_ip(pos)
        self.Rect.clamp_ip(surfrect)

    def start_move(self):
        self.before = self.Rect.center

    def cancel_move(self):
        if self.before is not None:
            self.Rect.center = self.before

    def complete_move(self):
        self.before = None

class Tower():
    def __init__(self, colour, num):
        box = pygame.Rect((0,0), (10, 144))
        box.center = (surfrect.w/4 * num , surfrect.h / 2)
        self.Rect = box
        self.num_rings = 0
        self.colour = colour
        self.rings = []

    def add_ring(self, ring):
        ring.Rect.center = self.Rect.center
        ring.Rect.bottom = self.Rect.bottom - ((ring.Rect.h+2)*self.num_rings)
        self.num_rings += 1
        self.rings.append(ring)

    def remove_ring(self, ring):
        self.num_rings -= 1
        self.rings.remove(ring)

    def collides(self, ring):
        return ring.Rect.colliderect(self.Rect)

    def draw(self):
        surface.fill(self.colour, self.Rect)

    def draw_rings(self):
        for ring in self.rings:
            ring.draw()
        
    def test_touch(self, pos):
        if len(self.rings) == 0:
            return None
        ring = self.rings[-1]
        if ring.touched(pos):
            return ring

    def can_drop(self, ring):
        if len(self.rings) == 0:
            return True
        top = self.rings[-1]
        if top.size > ring.size:
            return True
        return False

class Game():
    _moves = 0
    _touched = None
    _palette = [(255,0,0),(0,255,0),(0,0,255),(255,255,0),
               (0,255,255),(255,128,0),(128,255,0),(0,128,255)]
    def __init__(self, num_rings = 3):
        self.num_rings = num_rings

        tower1 = Tower((255,255,255), 1)
        tower2 = Tower((255,255,255), 2)
        tower3 = Tower((255,255,255), 3)

        for i in range(num_rings):
            tower1.add_ring(Ring(num_rings-i, self._palette[i]))

        self.towers = [tower1, tower2, tower3]

    def make_text(self, text, y, justification, font):
        padding = 10
        text_surface = font.render(text, False, (255, 255, 255))
        if(justification==RIGHT):
            x = surfrect.w - text_surface.get_width() - padding
        elif(justification==CENTER):
            x = surfrect.w /2 - text_surface.get_width()/2
        else:
            x = padding
        surface.blit(text_surface, (x,y))

    def draw(self):
        for tower in self.towers:
            tower.draw()
        for tower in self.towers:
            tower.draw_rings()
        self.make_text('Moves: ' + str(self._moves), 8, LEFT, small_font)

        currentTime = time.gmtime(time.time() - timePoint)
        timeStr = time.strftime("%M.%S", currentTime)
        self.make_text('Timer: ' + timeStr, 8, RIGHT, small_font) #
        self.make_text('Hanoi', 8, CENTER, my_font)

    def remove_ring(self, ring):
        for tower in self.towers:
            if ring in tower.rings:
                tower.remove_ring(ring)

    def mouse_down(self, pos):
        for tower in self.towers:
            ring = tower.test_touch(pos)
            if ring is not None:
                self._touched = ring 
                self._touched.start_move()
                pygame.mouse.get_rel()
                break
    
    def mouse_up(self): 
        if self._touched is not None:
            touching = False
            for tower in self.towers:
                if tower.collides(self._touched):   
                    if tower.can_drop(self._touched):
                        self.remove_ring(self._touched)    
                        tower.add_ring(self._touched)
                        touching = True
                        self._moves += 1

            if not touching:
                self._touched.cancel_move()
            self._touched = None

    def loop(self):
        if self._touched is not None:
            self._touched.move(pygame.mouse.get_rel())

    def check_win(self):
        if game.towers[-1].num_rings == self.num_rings:
            time.sleep(1)
            theywon()

try:
    game = Game(numberofrings)
except NameError:
    exit() 

x=0
while True:
    try:
        for ev in pygame.event.get():
            if ev.type == QUIT:
                pygame.quit()
            elif ev.type == pygame.MOUSEBUTTONDOWN:
                game.mouse_down(ev.pos)
            elif ev.type == pygame.MOUSEBUTTONUP:
                game.mouse_up()
        clock.tick(100)
        surface.fill((0, 0, 0))
        game.loop()
        game.draw()
        pygame.display.flip()
        x+=1
        game.check_win()
    except pygame.error:
        exit()
        #timer
        #save score 
        # retry
